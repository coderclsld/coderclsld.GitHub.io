import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as o,o as a}from"./app-C_wt19t6.js";const n={};function l(c,e){return a(),r("div",null,e[0]||(e[0]=[o('<h1 id="csrf与跨域" tabindex="-1"><a class="header-anchor" href="#csrf与跨域"><span>CSRF与跨域</span></a></h1><h3 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域"><span>什么是跨域</span></a></h3><h4 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h4><blockquote><p>同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。</p></blockquote><h3 id="跨域策略限制了哪些资源和操作" tabindex="-1"><a class="header-anchor" href="#跨域策略限制了哪些资源和操作"><span>跨域策略限制了哪些资源和操作</span></a></h3><blockquote><p>不允许发送POST请求：在发送POST请求之前会发送OPTIONS请求，HTTP响应状态码为403（Forbidden）<br> 允许发送GET请求：HTTP响应状态码为200，但是不能读取服务器返回的数据。</p></blockquote><h3 id="什么是同源-什么是不同源" tabindex="-1"><a class="header-anchor" href="#什么是同源-什么是不同源"><span>什么是同源，什么是不同源</span></a></h3><blockquote><p>举例来说，针对<a href="http://test.clsld.org/page.html%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%B8%80%E4%B8%8B%E6%83%85%E5%86%B5%E4%BC%9A%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E5%90%8C%E6%BA%90%E6%88%96%E5%8F%AA%E4%B8%8D%E5%90%8C%E6%BA%90" target="_blank" rel="noopener noreferrer">http://test.clsld.org/page.html这个地址，一下情况会被认为是同源或只不同源</a><br><a href="http://test.clsld.org/page2.html" target="_blank" rel="noopener noreferrer">http://test.clsld.org/page2.html</a> 同源 协议相同，主机名相同，端口名相同<br><a href="http://102.12.34.123/page.html" target="_blank" rel="noopener noreferrer">http://102.12.34.123/page.html</a> 不同源 主机名不同，域名与域名对应的ip不同源<br><a href="http://test2.clsld.org/page/html" target="_blank" rel="noopener noreferrer">http://test2.clsld.org/page/html</a> 不同源 主域名相同，子域名不同<br><a href="https://test.clsld.org/page/html" target="_blank" rel="noopener noreferrer">https://test.clsld.org/page/html</a> 不同源 协议不同</p></blockquote><h3 id="为什么会有浏览器限制" tabindex="-1"><a class="header-anchor" href="#为什么会有浏览器限制"><span>为什么会有浏览器限制</span></a></h3><blockquote><p>浏览器同源策略的提出本来就是为了避免数据安全的问题，即：限制来自不同源的脚本，在浏览器中同时打开某电商网站（<a href="http://xn--b-br6a69p0pe.com" target="_blank" rel="noopener noreferrer">域名为b.com</a>），同时在打开另一个网站(<a href="http://a.com" target="_blank" rel="noopener noreferrer">a.com</a>)，那么在a.com域名下的脚本可以读取b.com下的Cookie，如果Cookie中包含隐私数据，后果不堪设想。因为可以随意读取任意域名下的Cookie数据，很容易发起CSRF攻击。</p></blockquote><h3 id="如何解决跨域" tabindex="-1"><a class="header-anchor" href="#如何解决跨域"><span>如何解决跨域</span></a></h3><blockquote><p>1、nginx反向代理，我们都只到浏览器是判断域是否相同和请求头有无<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>来决定是否对该请求进行资源限制的，所以我们可以使用nginx反向代理，在服务器返回信息给nginx时在header头进行这些参数字段的设置，以此来解决跨域的问题。<br> 2、跨域资源共享（CORS）,服务端设置响应头的 access-control-allow-origin 的值为允许请求的域（客服端的）或设置为*（即匹配任意域名，任意客户端都可访问）；即可获取到该服务端响应的跨域资源。</p></blockquote><h3 id="什么是csrf" tabindex="-1"><a class="header-anchor" href="#什么是csrf"><span>什么是CSRF</span></a></h3><blockquote><p>SRF跨站伪造请求，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p></blockquote><blockquote><p>一个典型的CSRF攻击有着如下的流程：<br> 1、<a href="http://xn--a-f38al5vkzdt61bv7l.com" target="_blank" rel="noopener noreferrer">受害者登录a.com</a>，并保留了登录凭证（Cookie）。<br><a href="http://xn--b-nv6ao4io8bp6po6e00mu47cda4311avpa330h.com" target="_blank" rel="noopener noreferrer">攻击者引诱受害者访问了b.com</a>。<br><a href="http://b.com" target="_blank" rel="noopener noreferrer">b.com</a> 向 <a href="http://a.com" target="_blank" rel="noopener noreferrer">a.com</a> 发送了一个请求：<a href="http://a.com/act=xx%E3%80%82%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%90%BA%E5%B8%A6a.com%E7%9A%84Cookie%E3%80%82" target="_blank" rel="noopener noreferrer">a.com/act=xx。浏览器会默认携带a.com的Cookie。</a><br> a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。<br> a.com以受害者的名义执行了act=xx。<br> 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</p></blockquote><h3 id="怎么预防csrf" tabindex="-1"><a class="header-anchor" href="#怎么预防csrf"><span>怎么预防CSRF</span></a></h3><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener noreferrer">引用美团的博客</a></p>',17)]))}const s=t(n,[["render",l],["__file","CSRF与跨域.html.vue"]]),i=JSON.parse(`{"path":"/interview/CSRF%E4%B8%8E%E8%B7%A8%E5%9F%9F.html","title":"CSRF与跨域","lang":"en-US","frontmatter":{"date":"2024-08-22T00:00:00.000Z","order":99,"category":["interview"],"tag":["跨域"],"description":"CSRF与跨域 什么是跨域 定义 同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。 跨域策略限制了哪些资源和操作 不允许发送PO...","head":[["meta",{"property":"og:url","content":"https://github.com/coderclsld/coderclsld.github.io/interview/CSRF%E4%B8%8E%E8%B7%A8%E5%9F%9F.html"}],["meta",{"property":"og:site_name","content":"clsld 's blog"}],["meta",{"property":"og:title","content":"CSRF与跨域"}],["meta",{"property":"og:description","content":"CSRF与跨域 什么是跨域 定义 同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。 跨域策略限制了哪些资源和操作 不允许发送PO..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-09-13T07:48:09.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:tag","content":"跨域"}],["meta",{"property":"article:published_time","content":"2024-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-13T07:48:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CSRF与跨域\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-13T07:48:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[{"level":3,"title":"什么是跨域","slug":"什么是跨域","link":"#什么是跨域","children":[]},{"level":3,"title":"跨域策略限制了哪些资源和操作","slug":"跨域策略限制了哪些资源和操作","link":"#跨域策略限制了哪些资源和操作","children":[]},{"level":3,"title":"什么是同源，什么是不同源","slug":"什么是同源-什么是不同源","link":"#什么是同源-什么是不同源","children":[]},{"level":3,"title":"为什么会有浏览器限制","slug":"为什么会有浏览器限制","link":"#为什么会有浏览器限制","children":[]},{"level":3,"title":"如何解决跨域","slug":"如何解决跨域","link":"#如何解决跨域","children":[]},{"level":3,"title":"什么是CSRF","slug":"什么是csrf","link":"#什么是csrf","children":[]},{"level":3,"title":"怎么预防CSRF","slug":"怎么预防csrf","link":"#怎么预防csrf","children":[]}],"git":{"createdTime":1675147913000,"updatedTime":1726213689000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":1}]},"readingTime":{"minutes":3,"words":900},"filePathRelative":"interview/CSRF与跨域.md","localizedDate":"August 22, 2024","excerpt":"\\n<h3>什么是跨域</h3>\\n<h4>定义</h4>\\n<blockquote>\\n<p>同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。</p>\\n</blockquote>\\n<h3>跨域策略限制了哪些资源和操作</h3>\\n<blockquote>\\n<p>不允许发送POST请求：在发送POST请求之前会发送OPTIONS请求，HTTP响应状态码为403（Forbidden）<br>\\n允许发送GET请求：HTTP响应状态码为200，但是不能读取服务器返回的数据。</p>\\n</blockquote>","autoDesc":true}`);export{s as comp,i as data};
