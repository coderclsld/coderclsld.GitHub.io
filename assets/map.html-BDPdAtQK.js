import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-C_wt19t6.js";const t="/assets/57576986-acd87600-749f-11e9-8710-75e423c7efdb-Ww2f2xKi.png",e="/assets/57577391-f88f1d80-74a7-11e9-893c-4783dc4fb35e-B6L-4lBz.png",p="/assets/eb6ca7130cfc6b7da57663c9f2aa0a3b-B0jbj_ge.png",h={};function k(d,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>map</span></a></h1><blockquote><p><a href="https://www.cnblogs.com/qcrao-2018/p/10903807.html#map-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener noreferrer">map</a></p></blockquote><h2 id="map底层结构" tabindex="-1"><a class="header-anchor" href="#map底层结构"><span>map底层结构</span></a></h2><p>map的底层实现式一个hash表（数组+链表），使用拉链法消除hash冲突。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> hmap</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //元素个数，调用len(map)返回长度</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  count</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //bucket数量是2^B，最多可以存放loadFactor * 2^B,再多就要扩容了</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  B</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //hash seed</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  hash0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //指向bucket数组的指针(存放key val)；大小2^B</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  buckets</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pointer</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //扩容时，buckets长度时oldbuckets的两倍</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  oldbuckets</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Pointer</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> bmap</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //高位hash值数组</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  topbits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">uint8</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //存储key的数组</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  keys</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">keytype</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //存储val的数组</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  values</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">keytype</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //指向当前bucket的溢出桶</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  overflow</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uintptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //为了缓解当存在多个key计算后的hash值低8位相同的个数大于一个bucket所能存放的数目8个时，且这个map还没达到扩容条件时，做的一种存储设计。</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+t+'" alt="hashmap bmap" tabindex="0" loading="lazy"><figcaption>hashmap bmap</figcaption></figure><p>主要涉及结构体有两个，一个<code>hamp</code>，一个<code>bmap</code></p><p>对于<code>hamp</code>的buckets,他是<code>bmap</code>数组的指针。</p><figure><img src="'+e+'" alt="bmap struct" tabindex="0" loading="lazy"><figcaption>bmap struct</figcaption></figure><p>对于<code>bmap</code>：</p><ul><li>topbits数组记录的是当前bucket中key的高8位</li><li>overflow是指向哈希冲突时bucket满了，新构建出的bucket的指针。每个bmap的bucket最多只能放8个k-v键值对。如果碰巧有bucket存满了就需要构建出一个新的bucket并通过overflow指针连接起来，使得bucket形成一个链表。</li></ul><h2 id="map查找过程" tabindex="-1"><a class="header-anchor" href="#map查找过程"><span>map查找过程</span></a></h2><figure><img src="'+p+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><p>对于传进来的key值hash后key 经过哈希计算后得到哈希值，共 64 个 bit 位，计算它到底要落在哪个桶时会用到最后 B 个 bit 位。再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。如果没有key或者找不到，就会找到第一个空位放入，如果找到了就会修改val的值。如果bucket桶满了，就会创建新的bmap，放到新的bmap中，使用overflow链接起来。</p><h2 id="map扩容过程" tabindex="-1"><a class="header-anchor" href="#map扩容过程"><span>map扩容过程</span></a></h2><p>使用hash map的目的就是为了快速找到目标key、value，但是随着map中key越来越多，key发生hash碰撞的概率会越来越大，每个bucket的bmap8个位置都被塞满，甚至有的已经构建起来长长的链表，查找、插入、删除key的效率越来越低，所以bucket需要进行扩容了，减少key聚集在同一个bucket的情况。</p><p>map 扩容的时机：</p><ol><li>装载因子超过阈值，源码里定义的阈值是 6.5<code>（装载因子loadFactor := count / (2^B)）</code></li><li>overflow 的 bucket 数量过多： <ol><li>当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；</li><li>当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15</li></ol></li></ol><h2 id="并发map" tabindex="-1"><a class="header-anchor" href="#并发map"><span>并发map</span></a></h2><p>加sync.Mutex、sync.RWMutex</p><p>分片加锁，类似currentMap</p><p>sync.map</p>',22)]))}const o=s(h,[["render",k],["__file","map.html.vue"]]),m=JSON.parse(`{"path":"/golang/%E5%9F%BA%E7%A1%80/map.html","title":"map","lang":"en-US","frontmatter":{"description":"map map map底层结构 map的底层实现式一个hash表（数组+链表），使用拉链法消除hash冲突。 hashmap bmaphashmap bmap 主要涉及结构体有两个，一个hamp，一个bmap 对于hamp的buckets,他是bmap数组的指针。 bmap structbmap struct 对于bmap： topbits数组记录的是...","head":[["meta",{"property":"og:url","content":"https://github.com/coderclsld/coderclsld.github.io/golang/%E5%9F%BA%E7%A1%80/map.html"}],["meta",{"property":"og:site_name","content":"clsld 's blog"}],["meta",{"property":"og:title","content":"map"}],["meta",{"property":"og:description","content":"map map map底层结构 map的底层实现式一个hash表（数组+链表），使用拉链法消除hash冲突。 hashmap bmaphashmap bmap 主要涉及结构体有两个，一个hamp，一个bmap 对于hamp的buckets,他是bmap数组的指针。 bmap structbmap struct 对于bmap： topbits数组记录的是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-09-24T03:05:19.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:modified_time","content":"2024-09-24T03:05:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"map\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-24T03:05:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[{"level":2,"title":"map底层结构","slug":"map底层结构","link":"#map底层结构","children":[]},{"level":2,"title":"map查找过程","slug":"map查找过程","link":"#map查找过程","children":[]},{"level":2,"title":"map扩容过程","slug":"map扩容过程","link":"#map扩容过程","children":[]},{"level":2,"title":"并发map","slug":"并发map","link":"#并发map","children":[]}],"git":{"createdTime":1727147119000,"updatedTime":1727147119000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":1}]},"readingTime":{"minutes":2.51,"words":754},"filePathRelative":"golang/基础/map.md","localizedDate":"September 24, 2024","excerpt":"\\n<blockquote>\\n<p><a href=\\"https://www.cnblogs.com/qcrao-2018/p/10903807.html#map-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">map</a></p>\\n</blockquote>\\n<h2>map底层结构</h2>\\n<p>map的底层实现式一个hash表（数组+链表），使用拉链法消除hash冲突。</p>\\n<div class=\\"language-go line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"go\\" data-title=\\"go\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">type</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> hmap</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> struct</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //元素个数，调用len(map)返回长度</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  count</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> int</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //bucket数量是2^B，最多可以存放loadFactor * 2^B,再多就要扩容了</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  B</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> uint8</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //hash seed</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  hash0</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> uint32</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //指向bucket数组的指针(存放key val)；大小2^B</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  buckets</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> unsafe</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">.</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\">Pointer</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //扩容时，buckets长度时oldbuckets的两倍</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  oldbuckets</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> unsafe</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">.</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\">Pointer</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">type</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> bmap</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> struct</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //高位hash值数组</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  topbits</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> [</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">8</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">]</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">uint8</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //存储key的数组</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  keys</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> [</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">8</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">]</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\">keytype</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //存储val的数组</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  values</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> [</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">8</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">]</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\">keytype</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //指向当前bucket的溢出桶</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">  overflow</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> uintptr</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  //为了缓解当存在多个key计算后的hash值低8位相同的个数大于一个bucket所能存放的数目8个时，且这个map还没达到扩容条件时，做的一种存储设计。</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{o as comp,m as data};
