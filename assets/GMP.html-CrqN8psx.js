import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o}from"./app-C_wt19t6.js";const a="/assets/GM%E6%A8%A1%E5%9E%8B-DCM3Ys6b.gif",l="/assets/GMP%E5%9B%BE-CWlMnRZP.png",r="/assets/GMP%E6%A8%A1%E5%9E%8B1-BX_ZPwz0.gif",g="/assets/GMP%E6%A8%A1%E5%9E%8B-%E8%8E%B7%E5%8F%96%E5%85%A8%E5%B1%80%E5%8D%8F%E7%A8%8B%E9%98%9F%E5%88%97-B4tcqMon.gif",s="/assets/GMP%E6%A8%A1%E5%9E%8B-stealing2-BNJ5JYmN.gif",c={};function p(M,t){return o(),i("div",null,t[0]||(t[0]=[n('<h1 id="gmp" tabindex="-1"><a class="header-anchor" href="#gmp"><span>GMP</span></a></h1><h2 id="gm模型" tabindex="-1"><a class="header-anchor" href="#gm模型"><span>GM模型</span></a></h2><p>在go 1.1之前用的是GM模型，后面才是GMP模型。GM模型处理G和M之外还有一个全局队列，全局队列用来存放可运行状态的G。M如果想获取到G就需要访问全局队列，那么多个M同时访问就会存在并发问题，所以M进行返回的时候就会对全局队列进行加锁，这时候全局队列就会被一把大锁锁住，并发量大的话会造成性能瓶颈。</p><figure><img src="'+a+'" alt="GM模型" tabindex="0" loading="lazy"><figcaption>GM模型</figcaption></figure><h2 id="gmp模型是什么" tabindex="-1"><a class="header-anchor" href="#gmp模型是什么"><span>gmp模型是什么</span></a></h2><ul><li>G：goroutine，用户态线程，有自己对的栈，instruction pointer和其他信息（正在等待的channel等），用于调度</li><li>M：系统内核线程，操作系统是看不见G和P的，只知道自己在执行一个线程，G和P是在用户层上实现的</li><li>P：调度器processor，代表执行所需要的资源（调度的上下文，队列等），实现从N:1到N:M的关键</li></ul><figure><img src="'+l+'" alt="GMP图" tabindex="0" loading="lazy"><figcaption>GMP图</figcaption></figure><p>所以为了解决这个全局大锁的问题，加入了P调度器，P为本地的协程队列也是用来存放G的，想要获取等待运行的G会优先从本地队列里面拿，访问本地队列无需加锁，而全局队列依然是存在的，但是功能会被弱化，只有本地队列也为空的情况下才回到全局队列中去拿G.</p><figure><img src="'+r+'" alt="GMP模型" tabindex="0" loading="lazy"><figcaption>GMP模型</figcaption></figure><p>新建G时，新的G会优先加入到P的本地队列中，如果本地队列满了，就会从本地队列中的一半G移动到全局队列。</p><figure><img src="'+g+'" alt="GMP模型-获取全局协程队列" tabindex="0" loading="lazy"><figcaption>GMP模型-获取全局协程队列</figcaption></figure><p>当P的本地队列为空时M就会去全局队列中去拿取。如果全局队列也为空，M就会从其他P的本地队列中stealing一半G放到自己的P的本地队列中。</p><figure><img src="'+s+'" alt="GMP模型-stealing" tabindex="0" loading="lazy"><figcaption>GMP模型-stealing</figcaption></figure><h2 id="goroutine的状态" tabindex="-1"><a class="header-anchor" href="#goroutine的状态"><span>Goroutine的状态</span></a></h2><ul><li>idle:空闲，表示goroutine为被调度执行</li><li>runnable：可运行，表示goroutine已准备好运行，等待被标度到M上</li><li>running：运行中，表示goroutine在一个M上运行</li><li>syscall:系统调用，表示goroutine正在执行阻塞等待系统调用</li><li>waiting:等待，表示goroutine正在等待某个事件</li><li>dead：死亡，表示goroutine已被执行完成或被终止</li></ul>',15)]))}const d=e(c,[["render",p],["__file","GMP.html.vue"]]),u=JSON.parse(`{"path":"/golang/%E5%9F%BA%E7%A1%80/GMP.html","title":"GMP","lang":"en-US","frontmatter":{"description":"GMP GM模型 在go 1.1之前用的是GM模型，后面才是GMP模型。GM模型处理G和M之外还有一个全局队列，全局队列用来存放可运行状态的G。M如果想获取到G就需要访问全局队列，那么多个M同时访问就会存在并发问题，所以M进行返回的时候就会对全局队列进行加锁，这时候全局队列就会被一把大锁锁住，并发量大的话会造成性能瓶颈。 GM模型GM模型 gmp模型是...","head":[["meta",{"property":"og:url","content":"https://github.com/coderclsld/coderclsld.github.io/golang/%E5%9F%BA%E7%A1%80/GMP.html"}],["meta",{"property":"og:site_name","content":"clsld 's blog"}],["meta",{"property":"og:title","content":"GMP"}],["meta",{"property":"og:description","content":"GMP GM模型 在go 1.1之前用的是GM模型，后面才是GMP模型。GM模型处理G和M之外还有一个全局队列，全局队列用来存放可运行状态的G。M如果想获取到G就需要访问全局队列，那么多个M同时访问就会存在并发问题，所以M进行返回的时候就会对全局队列进行加锁，这时候全局队列就会被一把大锁锁住，并发量大的话会造成性能瓶颈。 GM模型GM模型 gmp模型是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-09-24T03:05:19.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:modified_time","content":"2024-09-24T03:05:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-24T03:05:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[{"level":2,"title":"GM模型","slug":"gm模型","link":"#gm模型","children":[]},{"level":2,"title":"gmp模型是什么","slug":"gmp模型是什么","link":"#gmp模型是什么","children":[]},{"level":2,"title":"Goroutine的状态","slug":"goroutine的状态","link":"#goroutine的状态","children":[]}],"git":{"createdTime":1725850736000,"updatedTime":1727147119000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":2}]},"readingTime":{"minutes":2.08,"words":625},"filePathRelative":"golang/基础/GMP.md","localizedDate":"September 9, 2024","excerpt":"\\n<h2>GM模型</h2>\\n<p>在go 1.1之前用的是GM模型，后面才是GMP模型。GM模型处理G和M之外还有一个全局队列，全局队列用来存放可运行状态的G。M如果想获取到G就需要访问全局队列，那么多个M同时访问就会存在并发问题，所以M进行返回的时候就会对全局队列进行加锁，这时候全局队列就会被一把大锁锁住，并发量大的话会造成性能瓶颈。</p>\\n<figure><figcaption>GM模型</figcaption></figure>\\n<h2>gmp模型是什么</h2>\\n<ul>\\n<li>G：goroutine，用户态线程，有自己对的栈，instruction pointer和其他信息（正在等待的channel等），用于调度</li>\\n<li>M：系统内核线程，操作系统是看不见G和P的，只知道自己在执行一个线程，G和P是在用户层上实现的</li>\\n<li>P：调度器processor，代表执行所需要的资源（调度的上下文，队列等），实现从N:1到N:M的关键</li>\\n</ul>","autoDesc":true}`);export{d as comp,u as data};
