import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as t,o as a}from"./app-C_wt19t6.js";const n={};function o(l,e){return a(),s("div",null,e[0]||(e[0]=[t(`<h1 id="mutex" tabindex="-1"><a class="header-anchor" href="#mutex"><span>mutex</span></a></h1><h3 id="互斥锁sync-mutex" tabindex="-1"><a class="header-anchor" href="#互斥锁sync-mutex"><span>互斥锁sync.Mutex</span></a></h3><p><code>Mutex.lock()</code>获取锁<br><code>Mutex.Unlock()</code>释放锁<br> 在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。</p><h4 id="sync-mutex的数据结构" tabindex="-1"><a class="header-anchor" href="#sync-mutex的数据结构"><span>sync.Mutex的数据结构</span></a></h4><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Mutex</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	state</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int32</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	sema</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sync.Mutex由两个字段构成，<strong>state用来代表当前互斥锁处于的状态（32位进行标识）</strong>，sema用于控制锁状态的信号量<br> 互斥锁主要记录了如下四种状态：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb72ab82c1a044f2ba460f472af7bf96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>waiter_num：记录当前等待抢这个锁的goroutine数量<br> starving：当前锁时候处于饥饿状态，0：正常状态，1：饥饿状态<br> woken：当前锁是否有goroutine已被唤醒。0：没有goroutine被唤醒，1：有goroutine正在加锁过程<br> locked：当前锁是否被goroutine持有。0：未被持有，1：已被持有<br> sema信号量的作用：当持有锁的goroutine释放锁后，会释放sema信号量，这个信号量会被唤醒之前抢锁阻塞的goroutine来获取锁</p><h4 id="锁的两种模式-正常模式和饥饿模式" tabindex="-1"><a class="header-anchor" href="#锁的两种模式-正常模式和饥饿模式"><span>锁的两种模式：正常模式和饥饿模式</span></a></h4><p>正常模式下，所有阻塞在等待队列中的goroutine会按顺序进行锁获取，当唤醒一个等待队列中的goroutine时，此goroutine并不会直接获取到锁，而是会和新请求锁的goroutine竞争。通常新请求锁的goroutine更容易获取锁，这是因为新请求锁的goroutine正在占用cpu片执行，大概率可以直接执行到获取到锁的逻辑。<br> 饥饿模式下， 新请求锁的goroutine不会进行锁获取，而是加入到队列尾部阻塞等待获取锁。<br> 饥饿模式的触发条件：当一个goroutine等待锁的时间超过了1ms，互斥锁会切换到饥饿模式<br> 饥饿模式的取消条件：当获取到这个锁的goroutine是等待锁队列中的最后一个goroutine，互斥锁会切换到正常模式；当获取到锁的这个goroutine的等待时间在1ms之内，互斥锁会切换到正常模式。</p><h4 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项：</span></a></h4><p>1、在一个goroutine中执行Lock()加锁成功后，不要再<strong>重复进行加锁，否则会panic</strong><br> 2、在Lock()之前执行Unlock()释放锁会panic<br> 3、对于同一把锁，可以在一个goroutine中执行Lock加锁成功后，可以在另一个goroutine中执行Unlock释放锁。</p><h3 id="读写锁sync-rwmutex" tabindex="-1"><a class="header-anchor" href="#读写锁sync-rwmutex"><span>读写锁sync.RWMutex</span></a></h3><blockquote><p>读写锁不限制对资源的并发读，但是读写、写写操作无法并行执行</p></blockquote><p><code>RLock()</code>申请读锁<br><code>RUnlock()</code>解除读锁<br><code>Lock()</code>申请写锁<br><code>Unlock()</code>解除写锁</p><h4 id="sync-rwmutex的数据结构" tabindex="-1"><a class="header-anchor" href="#sync-rwmutex的数据结构"><span>sync.RWMutex的数据结构</span></a></h4><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RWMutex</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	w</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Mutex</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //复用互斥锁</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	writeSem</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //写锁监听读锁释放的信号量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	readerSem</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //读锁监听写锁释放的信号量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	readerCount</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //当前正在执行读操作的数量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	readerWait</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int32</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //当写操作被阻塞时，需要等待读操作完成的个数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读操作如何防止并发读写问题" tabindex="-1"><a class="header-anchor" href="#读操作如何防止并发读写问题"><span>读操作如何防止并发读写问题？</span></a></h4><ul><li>RLock()申请读锁，每次执行该函数都会对readerCount++，此时当有写操作执行Lock()时会判断readerCount &gt; 0，就会被阻塞</li><li>RUnLock()解除读锁，执行readerCount--，释放信号量唤醒等待写操作的goroutine</li></ul><h4 id="写操作如何防止并发读写、并发写写问题" tabindex="-1"><a class="header-anchor" href="#写操作如何防止并发读写、并发写写问题"><span>写操作如何防止并发读写、并发写写问题？</span></a></h4><ul><li>Lock()申请写锁，获取互斥锁，此时会阻塞其他的写操作，并将readerCount置为-1，当有读操作进来时发现readerCount = -1，就知道了有写操作在进行，阻塞。</li><li>Unlock()解除写锁，会先通知所有阻塞的读操作goroutine，然后才会释放持有的互斥锁。</li></ul><h4 id="为什么写操作不会被饿死" tabindex="-1"><a class="header-anchor" href="#为什么写操作不会被饿死"><span>为什么写操作不会被饿死？</span></a></h4><ul><li>什么是写操作被饿死？这是由于写操作要等待读操作结束后才可以获取锁，而写操作在等待期间可能还有新的读操作持续到来，如果写操作等待所有的读操作结束，很可能会一直阻塞，这种现象叫做写操作被饿死</li><li>通过RWMutex结构体中你的readerWait属性可以完美解决这个问题，当写操作到来是，会把RWMutex.readerCount值拷贝到RWMutex.readerWait中，用于标记在写操作面前的读操作个数，前面的读操作结束后，除了会递减RWMutex.readerCount，还会递减RWMutex.readerWait值，当RWMutex.readWait值变为0时唤醒写操作。</li></ul><h3 id="读写锁和互斥锁的区别" tabindex="-1"><a class="header-anchor" href="#读写锁和互斥锁的区别"><span>读写锁和互斥锁的区别</span></a></h3><p>go语言标准库<code>sync</code>提供了两种锁，互斥锁<code>sync.Mutex</code>和读写锁<code>sync.RWMutex</code></p><p><code>sync.Mutex</code>,有两个方法，<code>Lock</code>和<code>Unlock</code>,我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用<code>Unlock</code>方法来保证一段代码的互斥执行，也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 <code>Lock</code> 方法获得锁后，其他请求锁的协程都会阻塞在 <code>Lock </code>方法，直到锁被释放。</p><p><code>sync.RWMutex</code>,读写锁分为读锁和写锁，读锁是允许同时执行的，但写锁是互斥的。<code>sync.RWMutex</code>提供四个方法，<code>Lock</code>加写锁，<code>Unlock </code>释放写锁，<code>RLock </code>加读锁，<code>RUnlock</code>释放读锁</p><p>读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。</p><p>写锁之间是互斥的，存在写锁，其他写锁阻塞。</p><p>写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。</p><p>互斥锁如何实现公平</p><blockquote><p>互斥锁有两种状态：正常状态(非公平锁)和饥饿状态（公平锁）。</p><p>在正常状态下，所有等待锁的<code> goroutine</code> 按照FIFO顺序等待。唤醒的<code>goroutine</code>不会直接拥有锁，而是会和新请求锁的<code>goroutine</code>竞争锁的拥有。新请求锁的 <code>goroutine</code> 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的<code>goroutine</code> 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒 <code>goroutine</code>会加入到等待队列的前面。 如果一个等待的 <code>goroutine</code> 超过 <code>1ms </code>没有获取锁，那么它将会把锁转变为饥饿模式。</p><p>在饥饿模式下，锁的所有权将从 unlock 的 <code>goroutine</code> 直接交给交给等待队列中的第一个。新来的 <code>goroutine</code> 将不会尝试去获得锁，即使锁看起来是 unlock 状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</p><p>如果一个等待的 <code>goroutine</code> 获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于<code>1ms</code>。它会将锁的状态转换为正常状态。</p><p>正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p></blockquote>`,32)]))}const d=i(n,[["render",o],["__file","mutex.html.vue"]]),p=JSON.parse(`{"path":"/golang/%E5%9F%BA%E7%A1%80/mutex.html","title":"mutex","lang":"en-US","frontmatter":{"date":"2024-08-22T00:00:00.000Z","category":["Golang"],"tag":["Go"],"description":"mutex 互斥锁sync.Mutex Mutex.lock()获取锁 Mutex.Unlock()释放锁 在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。 sync.Mutex的数据结构 sync.Mutex由两个字段构成，state...","head":[["meta",{"property":"og:url","content":"https://github.com/coderclsld/coderclsld.github.io/golang/%E5%9F%BA%E7%A1%80/mutex.html"}],["meta",{"property":"og:site_name","content":"clsld 's blog"}],["meta",{"property":"og:title","content":"mutex"}],["meta",{"property":"og:description","content":"mutex 互斥锁sync.Mutex Mutex.lock()获取锁 Mutex.Unlock()释放锁 在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。 sync.Mutex的数据结构 sync.Mutex由两个字段构成，state..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb72ab82c1a044f2ba460f472af7bf96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-09-10T15:53:31.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:published_time","content":"2024-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-10T15:53:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"mutex\\",\\"image\\":[\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb72ab82c1a044f2ba460f472af7bf96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\\"],\\"datePublished\\":\\"2024-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-10T15:53:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[{"level":3,"title":"互斥锁sync.Mutex","slug":"互斥锁sync-mutex","link":"#互斥锁sync-mutex","children":[]},{"level":3,"title":"读写锁sync.RWMutex","slug":"读写锁sync-rwmutex","link":"#读写锁sync-rwmutex","children":[]},{"level":3,"title":"读写锁和互斥锁的区别","slug":"读写锁和互斥锁的区别","link":"#读写锁和互斥锁的区别","children":[]}],"git":{"createdTime":1675147913000,"updatedTime":1725983611000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":1}]},"readingTime":{"minutes":5.85,"words":1754},"filePathRelative":"golang/基础/mutex.md","localizedDate":"August 22, 2024","excerpt":"\\n<h3>互斥锁sync.Mutex</h3>\\n<p><code>Mutex.lock()</code>获取锁<br>\\n<code>Mutex.Unlock()</code>释放锁<br>\\n在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。</p>\\n<h4>sync.Mutex的数据结构</h4>\\n<div class=\\"language-go line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"go\\" data-title=\\"go\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">type</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> Mutex</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> struct</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">\\tstate</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> int32</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">\\tsema</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> uint32</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{d as comp,p as data};
