import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as s,a as t}from"./app-DevuHzse.js";const a={},n=t(`<h1 id="mutex" tabindex="-1"><a class="header-anchor" href="#mutex"><span>mutex</span></a></h1><h3 id="互斥锁sync-mutex" tabindex="-1"><a class="header-anchor" href="#互斥锁sync-mutex"><span>互斥锁sync.Mutex</span></a></h3><p><code>Mutex.lock()</code>获取锁 <code>Mutex.Unlock()</code>释放锁 在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。</p><h4 id="sync-mutex的数据结构" tabindex="-1"><a class="header-anchor" href="#sync-mutex的数据结构"><span>sync.Mutex的数据结构</span></a></h4><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Mutex</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	state</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int32</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	sema</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sync.Mutex由两个字段构成，state用来代表当前互斥锁处于的状态，sema用于控制锁状态的信号量 互斥锁主要记录了如下四种状态：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb72ab82c1a044f2ba460f472af7bf96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>waiter_num：记录当前等待抢这个锁的goroutine数量 starving：当前锁时候处于饥饿状态，0：正常状态，1：饥饿状态 woken：当前锁是否有goroutine已被唤醒。0：没有goroutine被唤醒，1：有goroutine正在加锁过程 locked：当前锁是否被goroutine持有。0：未被持有，1：已被持有 sema信号量的作用：当持有锁的goroutine释放锁后，会释放sema信号量，这个信号量会被唤醒之前抢锁阻塞的goroutine来获取锁</p><h4 id="锁的两种模式-正常模式和饥饿模式" tabindex="-1"><a class="header-anchor" href="#锁的两种模式-正常模式和饥饿模式"><span>锁的两种模式：正常模式和饥饿模式</span></a></h4><p>正常模式下，所有阻塞在等待队列中的goroutine会按顺序进行锁获取，当唤醒一个等待队列中的goroutine时，此goroutine并不会直接获取到锁，而是会和新请求锁的goroutine竞争。 通常新请求锁的goroutine更容易获取锁，这是因为新请求锁的goroutine正在占用cpu片执行，大概率可以直接执行到获取到锁的逻辑。 饥饿模式下， 新请求锁的goroutine不会进行锁获取，而是加入到队列尾部阻塞等待获取锁。 饥饿模式的触发条件：当一个goroutine等待锁的时间超过了1ms，互斥锁会切换到饥饿模式 饥饿模式的取消条件：当获取到这个锁的goroutine是等待锁队列中的最后一个goroutine，互斥锁会切换到正常模式；当获取到锁的这个goroutine的等待时间在1ms之内，互斥锁会切换到正常模式。</p><h4 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项：</span></a></h4><p>1、在一个goroutine中执行Lock()加锁成功后，不要再重复进行加锁，否则会panic 2、在Lock()之前执行Unlock()释放锁会panic 3、对于同一把锁，可以在一个goroutine中执行Lock加锁成功后，可以在另一个goroutine中执行Unlock释放锁。</p><h3 id="读写锁sync-rwmutex" tabindex="-1"><a class="header-anchor" href="#读写锁sync-rwmutex"><span>读写锁sync.RWMutex</span></a></h3><blockquote><p>读写锁不限制对资源的并发读，但是读写、写写操作无法并行执行</p></blockquote><p><code>RLock()</code>申请读锁 <code>RUnlock()</code>解除读锁 <code>Lock()</code>申请写锁 <code>Unlock()</code>解除写锁</p><h4 id="sync-rwmutex的数据结构" tabindex="-1"><a class="header-anchor" href="#sync-rwmutex的数据结构"><span>sync.RWMutex的数据结构</span></a></h4><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RWMutex</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	w</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Mutex</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> //复用互斥锁</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	writeSem</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> //写锁监听读锁释放的信号量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	readerSem</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> //读锁监听写锁释放的信号量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	readerCount</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> uint32</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> //当前正在执行读操作的数量</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">	readerWait</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int32</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> //当写操作被阻塞时，需要等待读操作完成的个数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读操作如何防止并发读写问题" tabindex="-1"><a class="header-anchor" href="#读操作如何防止并发读写问题"><span>读操作如何防止并发读写问题？</span></a></h4><ul><li>RLock()申请读锁，每次执行该函数都会对readerCount++，此时当有写操作执行Lock()时会判断readerCount &gt; 0，就会被阻塞</li><li>RUnLock()解除读锁，执行readerCount--，释放信号量唤醒等待写操作的goroutine</li></ul><h4 id="写操作如何防止并发读写、并发写写问题" tabindex="-1"><a class="header-anchor" href="#写操作如何防止并发读写、并发写写问题"><span>写操作如何防止并发读写、并发写写问题？</span></a></h4><ul><li>Lock()申请写锁，获取互斥锁，此时会阻塞其他的写操作，并将readerCount置为-1，当有读操作进来时发现readerCount = -1，就知道了有写操作在进行，阻塞。</li><li>Unlock()解除写锁，会先通知所有阻塞的读操作goroutine，然后才会释放持有的互斥锁。</li></ul><h4 id="为什么写操作不会被饿死" tabindex="-1"><a class="header-anchor" href="#为什么写操作不会被饿死"><span>为什么写操作不会被饿死？</span></a></h4><ul><li>什么事写操作被饿死？这是由于写操作要等待读操作结束后才可以获取锁，而写操作在等待期间可能还有新的读操作持续到来，如果写操作等待所有的读操作结束，很可能会一直阻塞，这种现象叫做写操作被饿死</li><li>通过RWMutex结构体中你的readerWait属性可以完美解决这个问题，当写操作到来是，会把RWMutex.readerCount值拷贝到RWMutex.readerWait中，用于标记在写操作面前的读操作个数，前面的读操作结束后，除了会递减RWMutex.readerCount，还会递减RWMutex.readerWait值，当RWMutex.readWait值变为0时唤醒写操作。</li></ul>`,23),l=[n];function r(o,h){return s(),e("div",null,l)}const d=i(a,[["render",r],["__file","mutex.html.vue"]]),k=JSON.parse(`{"path":"/posts/golang/mutex.html","title":"mutex","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2024-08-22T00:00:00.000Z","category":["Golang"],"tag":["Go"],"description":"mutex 互斥锁sync.Mutex Mutex.lock()获取锁 Mutex.Unlock()释放锁 在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。 sync.Mutex的数据结构 sync.Mutex由两个字段构成，state...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/golang/mutex.html"}],["meta",{"property":"og:site_name","content":"Clsld 's blog"}],["meta",{"property":"og:title","content":"mutex"}],["meta",{"property":"og:description","content":"mutex 互斥锁sync.Mutex Mutex.lock()获取锁 Mutex.Unlock()释放锁 在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。 sync.Mutex的数据结构 sync.Mutex由两个字段构成，state..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb72ab82c1a044f2ba460f472af7bf96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-08-22T16:58:49.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:published_time","content":"2024-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-22T16:58:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"mutex\\",\\"image\\":[\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb72ab82c1a044f2ba460f472af7bf96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\\"],\\"datePublished\\":\\"2024-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-22T16:58:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[{"level":3,"title":"互斥锁sync.Mutex","slug":"互斥锁sync-mutex","link":"#互斥锁sync-mutex","children":[]},{"level":3,"title":"读写锁sync.RWMutex","slug":"读写锁sync-rwmutex","link":"#读写锁sync-rwmutex","children":[]}],"git":{"createdTime":1675147913000,"updatedTime":1724345929000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":1}]},"readingTime":{"minutes":3.78,"words":1133},"filePathRelative":"posts/golang/mutex.md","localizedDate":"August 22, 2024","excerpt":"\\n<h3>互斥锁sync.Mutex</h3>\\n<p><code>Mutex.lock()</code>获取锁\\n<code>Mutex.Unlock()</code>释放锁\\n在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。</p>\\n<h4>sync.Mutex的数据结构</h4>\\n<div class=\\"language-go line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"go\\" data-title=\\"go\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">type</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> Mutex</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> struct</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">\\tstate</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> int32</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">\\tsema</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> uint32</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{d as comp,k as data};
