import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as r}from"./app-C_wt19t6.js";const i={};function n(p,e){return r(),a("div",null,e[0]||(e[0]=[l('<h1 id="cpu飙高性能排查" tabindex="-1"><a class="header-anchor" href="#cpu飙高性能排查"><span>cpu飙高性能排查</span></a></h1><h2 id="cpu-load比较高-怎么排查" tabindex="-1"><a class="header-anchor" href="#cpu-load比较高-怎么排查"><span>cpu load比较高，怎么排查？</span></a></h2><h3 id="linux进程状态" tabindex="-1"><a class="header-anchor" href="#linux进程状态"><span>linux进程状态</span></a></h3><p>D（task_uninterruptiblr） 不可中断睡眠态，这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用kill -9杀死的(kill也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由I/O等待(比如磁盘I/O、网络I/O、外设I/O等)引起，出现时间非常短暂，大多很难被PS或者TOP命令捕获(除非I/O HANG死)。<br> R（task_running）可执行态，这种状态的进程都位于CPU的可执行队列中，正在运行或者正在等待运行<br> S（task_interruptible）可中断睡眠，这种状态的进程虽然也处于睡眠中，但是是允许被中断的。这种进程一般在等待某事件的发生（比如socket连接、信号量等），而被挂起。一旦这些时间完成，进程将被唤醒转为R态。如果不在高负载时期，系统中大部分进程都处于S态。SLEEP态进程不会占用任何CPU资源。<br> T&amp;t（task_stop&amp;task_traced）暂停&amp;跟踪态，这种两种状态的进程都处于运行停止的状态。不同之处是暂停态一般由于收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT四种信号被停止，而跟踪态是由于进程被另一个进程跟踪引起(比如gdb断点），暂停态进程会释放所有占用资源。<br> Z (exit_zomble) 僵尸态，这种状态的进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID等）<br> X（exit_dead）死亡态，进程的真正结束态</p><h3 id="load-average-平均负载" tabindex="-1"><a class="header-anchor" href="#load-average-平均负载"><span>load average(平均负载)</span></a></h3><p>LoadAverage = calc_load(Task_RUNNING+TASK_UNINTERRUPTIBLE,n)<br> 平均负载(load average)是指系统的运行队列的平均利用率，也可以认为是可运行进程的平均数。<br> top命令中load average显示的是最近1分钟、5分钟和15分钟的系统平均负载</p><h3 id="cpu使用率" tabindex="-1"><a class="header-anchor" href="#cpu使用率"><span>CPU使用率</span></a></h3><p>CPU的时间分片一般可分为4大类：<br> 用户进程运行时间 - User Time<br> 系统内核运行时间 - System Time<br> 空闲时间 - Idle Time<br> 被抢占时间 - Steal Time<br> 除了Idle Time外，其余时间CPU都处于工作运行状态。</p><p>us：用户进程空间中未改变过优先级的进程占用CPU百分比<br> sy：内核空间占用CPU百分比<br> ni：用户进程空间内改变过优先级的进程占用CPU百分比<br> id：空闲时间百分比<br> wa：空闲&amp;等待I/O的时间百分比<br> hi：硬中断时间百分比<br> si：软中断时间百分比<br> st：虚拟化时被其余VM窃取时间百分比</p><h3 id="load高-cpu高" tabindex="-1"><a class="header-anchor" href="#load高-cpu高"><span>load高&amp;CPU高</span></a></h3><p>即load上涨是CPU负载上升导致</p><p>当go服务部署到线上了，发现有内存泄露，该怎么处理</p>',12)]))}const d=t(i,[["render",n],["__file","CPU飙高性能排查.html.vue"]]),s=JSON.parse(`{"path":"/linux/CPU%E9%A3%99%E9%AB%98%E6%80%A7%E8%83%BD%E6%8E%92%E6%9F%A5.html","title":"cpu飙高性能排查","lang":"en-US","frontmatter":{"date":"2024-08-22T00:00:00.000Z","category":["Linux"],"tag":["linux"],"description":"cpu飙高性能排查 cpu load比较高，怎么排查？ linux进程状态 D（task_uninterruptiblr） 不可中断睡眠态，这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用kill -9杀死的(kill也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由I/O等待(比...","head":[["meta",{"property":"og:url","content":"https://github.com/coderclsld/coderclsld.github.io/linux/CPU%E9%A3%99%E9%AB%98%E6%80%A7%E8%83%BD%E6%8E%92%E6%9F%A5.html"}],["meta",{"property":"og:site_name","content":"clsld 's blog"}],["meta",{"property":"og:title","content":"cpu飙高性能排查"}],["meta",{"property":"og:description","content":"cpu飙高性能排查 cpu load比较高，怎么排查？ linux进程状态 D（task_uninterruptiblr） 不可中断睡眠态，这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用kill -9杀死的(kill也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由I/O等待(比..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-09-09T02:58:56.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2024-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-09T02:58:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"cpu飙高性能排查\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-09T02:58:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[{"level":2,"title":"cpu load比较高，怎么排查？","slug":"cpu-load比较高-怎么排查","link":"#cpu-load比较高-怎么排查","children":[{"level":3,"title":"linux进程状态","slug":"linux进程状态","link":"#linux进程状态","children":[]},{"level":3,"title":"load average(平均负载)","slug":"load-average-平均负载","link":"#load-average-平均负载","children":[]},{"level":3,"title":"CPU使用率","slug":"cpu使用率","link":"#cpu使用率","children":[]},{"level":3,"title":"load高&CPU高","slug":"load高-cpu高","link":"#load高-cpu高","children":[]}]}],"git":{"createdTime":1675147913000,"updatedTime":1725850736000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":1}]},"readingTime":{"minutes":2.51,"words":753},"filePathRelative":"linux/CPU飙高性能排查.md","localizedDate":"August 22, 2024","excerpt":"\\n<h2>cpu load比较高，怎么排查？</h2>\\n<h3>linux进程状态</h3>\\n<p>D（task_uninterruptiblr） 不可中断睡眠态，这种状态的进程处于睡眠中，并且不允许被其他进程或中断(异步信号)打断。因此这种状态的进程，是无法使用kill -9杀死的(kill也是一种信号)，除非重启系统(没错，就是这么头硬)。不过这种状态一般由I/O等待(比如磁盘I/O、网络I/O、外设I/O等)引起，出现时间非常短暂，大多很难被PS或者TOP命令捕获(除非I/O HANG死)。<br>\\nR（task_running）可执行态，这种状态的进程都位于CPU的可执行队列中，正在运行或者正在等待运行<br>\\nS（task_interruptible）可中断睡眠，这种状态的进程虽然也处于睡眠中，但是是允许被中断的。这种进程一般在等待某事件的发生（比如socket连接、信号量等），而被挂起。一旦这些时间完成，进程将被唤醒转为R态。如果不在高负载时期，系统中大部分进程都处于S态。SLEEP态进程不会占用任何CPU资源。<br>\\nT&amp;t（task_stop&amp;task_traced）暂停&amp;跟踪态，这种两种状态的进程都处于运行停止的状态。不同之处是暂停态一般由于收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT四种信号被停止，而跟踪态是由于进程被另一个进程跟踪引起(比如gdb断点），暂停态进程会释放所有占用资源。<br>\\nZ (exit_zomble) 僵尸态，这种状态的进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID等）<br>\\nX（exit_dead）死亡态，进程的真正结束态</p>","autoDesc":true}`);export{d as comp,s as data};
