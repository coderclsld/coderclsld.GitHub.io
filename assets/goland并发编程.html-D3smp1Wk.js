import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as c,a as t}from"./app-DevuHzse.js";const d={},n=t('<h1 id="读写锁和互斥锁的区别" tabindex="-1"><a class="header-anchor" href="#读写锁和互斥锁的区别"><span>读写锁和互斥锁的区别</span></a></h1><p>go语言标准库<code>sync</code>提供了两种锁，互斥锁<code>sync.Mutex</code>和读写锁<code>sync.RWMutex</code></p><p><code>sync.Mutex</code>,有两个方法，<code>Lock</code>和<code>Unlock</code>,我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用<code>Unlock</code>方法来保证一段代码的互斥执行，也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 <code>Lock</code> 方法获得锁后，其他请求锁的协程都会阻塞在 <code>Lock </code>方法，直到锁被释放。</p><p><code>sync.RWMutex</code>,读写锁分为读锁和写锁，读锁是允许同时执行的，但写锁是互斥的。<code>sync.RWMutex</code>提供四个方法，<code>Lock</code>加写锁，<code>Unlock </code>释放写锁，<code>RLock </code>加读锁，<code>RUnlock</code>释放读锁</p><p>读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。</p><p>写锁之间是互斥的，存在写锁，其他写锁阻塞。</p><p>写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。</p><p>互斥锁如何实现公平</p><blockquote><p>互斥锁有两种状态：正常状态和饥饿状态。</p><p>在正常状态下，所有等待锁的<code> goroutine</code> 按照FIFO顺序等待。唤醒的<code>goroutine</code>不会直接拥有锁，而是会和新请求锁的<code>goroutine</code>竞争锁的拥有。新请求锁的 <code>goroutine</code> 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的<code>goroutine</code> 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒 <code>goroutine</code>会加入到等待队列的前面。 如果一个等待的 <code>goroutine</code> 超过 <code>1ms </code>没有获取锁，那么它将会把锁转变为饥饿模式。</p><p>在饥饿模式下，锁的所有权将从 unlock 的 <code>goroutine</code> 直接交给交给等待队列中的第一个。新来的 <code>goroutine</code> 将不会尝试去获得锁，即使锁看起来是 unlock 状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</p><p>如果一个等待的 <code>goroutine</code> 获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于<code>1ms</code>。它会将锁的状态转换为正常状态。</p><p>正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p></blockquote>',9),r=[n];function p(a,s){return c(),o("div",null,r)}const u=e(d,[["render",p],["__file","goland并发编程.html.vue"]]),g=JSON.parse(`{"path":"/posts/golang/goland%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html","title":"读写锁和互斥锁的区别","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2024-08-22T00:00:00.000Z","category":["Golang"],"tag":["Go"],"description":"读写锁和互斥锁的区别 go语言标准库sync提供了两种锁，互斥锁sync.Mutex和读写锁sync.RWMutex sync.Mutex,有两个方法，Lock和Unlock,我们可以通过在代码前调用 Lock 方法，在代码后调用Unlock方法来保证一段代码的互斥执行，也可以用 defer 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 Loc...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/golang/goland%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"Clsld 's blog"}],["meta",{"property":"og:title","content":"读写锁和互斥锁的区别"}],["meta",{"property":"og:description","content":"读写锁和互斥锁的区别 go语言标准库sync提供了两种锁，互斥锁sync.Mutex和读写锁sync.RWMutex sync.Mutex,有两个方法，Lock和Unlock,我们可以通过在代码前调用 Lock 方法，在代码后调用Unlock方法来保证一段代码的互斥执行，也可以用 defer 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 Loc..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-08-22T16:58:49.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:published_time","content":"2024-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-22T16:58:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"读写锁和互斥锁的区别\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-22T16:58:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[],"git":{"createdTime":1675147913000,"updatedTime":1724345929000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":1}]},"readingTime":{"minutes":2.08,"words":624},"filePathRelative":"posts/golang/goland并发编程.md","localizedDate":"August 22, 2024","excerpt":"\\n<p>go语言标准库<code>sync</code>提供了两种锁，互斥锁<code>sync.Mutex</code>和读写锁<code>sync.RWMutex</code></p>\\n<p><code>sync.Mutex</code>,有两个方法，<code>Lock</code>和<code>Unlock</code>,我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用<code>Unlock</code>方法来保证一段代码的互斥执行，也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 <code>Lock</code> 方法获得锁后，其他请求锁的协程都会阻塞在 <code>Lock </code>方法，直到锁被释放。</p>","autoDesc":true}`);export{u as comp,g as data};
