import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o,a}from"./app-DevuHzse.js";const c={},l=a('<h1 id="csrf与跨域" tabindex="-1"><a class="header-anchor" href="#csrf与跨域"><span>CSRF与跨域</span></a></h1><h3 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域"><span>什么是跨域</span></a></h3><h4 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h4><blockquote><p>同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。</p></blockquote><h3 id="跨域策略限制了哪些资源和操作" tabindex="-1"><a class="header-anchor" href="#跨域策略限制了哪些资源和操作"><span>跨域策略限制了哪些资源和操作</span></a></h3><blockquote><p>不允许发送POST请求：在发送POST请求之前会发送OPTIONS请求，HTTP响应状态码为403（Forbidden） 允许发送GET请求：HTTP响应状态码为200，但是不能读取服务器返回的数据。</p></blockquote><h3 id="什么是同源-什么是不同源" tabindex="-1"><a class="header-anchor" href="#什么是同源-什么是不同源"><span>什么是同源，什么是不同源</span></a></h3><blockquote><p>举例来说，针对http://test.clsld.org/page.html这个地址，一下情况会被认为是同源或只不同源 http://test.clsld.org/page2.html 同源 协议相同，主机名相同，端口名相同 http://102.12.34.123/page.html 不同源 主机名不同，域名与域名对应的ip不同源 http://test2.clsld.org/page/html 不同源 主域名相同，子域名不同 https://test.clsld.org/page/html 不同源 协议不同</p></blockquote><h3 id="为什么会有浏览器限制" tabindex="-1"><a class="header-anchor" href="#为什么会有浏览器限制"><span>为什么会有浏览器限制</span></a></h3><blockquote><p>浏览器同源策略的提出本来就是为了避免数据安全的问题，即：限制来自不同源的脚本，在浏览器中同时打开某电商网站（域名为b.com），同时在打开另一个网站(a.com)，那么在a.com域名下的脚本可以读取b.com下的Cookie，如果Cookie中包含隐私数据，后果不堪设想。因为可以随意读取任意域名下的Cookie数据，很容易发起CSRF攻击。</p></blockquote><h3 id="如何解决跨域" tabindex="-1"><a class="header-anchor" href="#如何解决跨域"><span>如何解决跨域</span></a></h3><blockquote><p>1、nginx反向代理，我们都只到浏览器是判断域是否相同和请求头有无<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>来决定是否对该请求进行资源限制的，所以我们可以使用nginx反向代理，在服务器返回信息给nginx时在header头进行这些参数字段的设置，以此来解决跨域的问题。 2、跨域资源共享（CORS）,服务端设置响应头的 access-control-allow-origin 的值为允许请求的域（客服端的）或设置为*（即匹配任意域名，任意客户端都可访问）；即可获取到该服务端响应的跨域资源。</p></blockquote><h3 id="什么是csrf" tabindex="-1"><a class="header-anchor" href="#什么是csrf"><span>什么是CSRF</span></a></h3><blockquote><p>SRF跨站伪造请求，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p></blockquote><blockquote><p>一个典型的CSRF攻击有着如下的流程： 1、受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。 a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</p></blockquote><h3 id="怎么预防csrf" tabindex="-1"><a class="header-anchor" href="#怎么预防csrf"><span>怎么预防CSRF</span></a></h3><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener noreferrer">引用美团的博客</a></p>',17),n=[l];function r(s,i){return o(),t("div",null,n)}const d=e(c,[["render",r],["__file","CSRF与跨域.html.vue"]]),m=JSON.parse(`{"path":"/posts/planlearn/interview/CSRF%E4%B8%8E%E8%B7%A8%E5%9F%9F.html","title":"CSRF与跨域","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2024-08-22T00:00:00.000Z","order":99,"category":["interview"],"tag":["跨域"],"description":"CSRF与跨域 什么是跨域 定义 同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。 跨域策略限制了哪些资源和操作 不允许发送PO...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/planlearn/interview/CSRF%E4%B8%8E%E8%B7%A8%E5%9F%9F.html"}],["meta",{"property":"og:site_name","content":"Clsld 's blog"}],["meta",{"property":"og:title","content":"CSRF与跨域"}],["meta",{"property":"og:description","content":"CSRF与跨域 什么是跨域 定义 同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。 跨域策略限制了哪些资源和操作 不允许发送PO..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-08-22T16:58:49.000Z"}],["meta",{"property":"article:author","content":"clsld"}],["meta",{"property":"article:tag","content":"跨域"}],["meta",{"property":"article:published_time","content":"2024-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-22T16:58:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CSRF与跨域\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-22T16:58:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"clsld\\",\\"url\\":\\"https://github.com/coderclsld\\"}]}"]]},"headers":[{"level":3,"title":"什么是跨域","slug":"什么是跨域","link":"#什么是跨域","children":[]},{"level":3,"title":"跨域策略限制了哪些资源和操作","slug":"跨域策略限制了哪些资源和操作","link":"#跨域策略限制了哪些资源和操作","children":[]},{"level":3,"title":"什么是同源，什么是不同源","slug":"什么是同源-什么是不同源","link":"#什么是同源-什么是不同源","children":[]},{"level":3,"title":"为什么会有浏览器限制","slug":"为什么会有浏览器限制","link":"#为什么会有浏览器限制","children":[]},{"level":3,"title":"如何解决跨域","slug":"如何解决跨域","link":"#如何解决跨域","children":[]},{"level":3,"title":"什么是CSRF","slug":"什么是csrf","link":"#什么是csrf","children":[]},{"level":3,"title":"怎么预防CSRF","slug":"怎么预防csrf","link":"#怎么预防csrf","children":[]}],"git":{"createdTime":1675147913000,"updatedTime":1724345929000,"contributors":[{"name":"clsld","email":"807686672@qq.com","commits":1}]},"readingTime":{"minutes":3.01,"words":904},"filePathRelative":"posts/planlearn/interview/CSRF与跨域.md","localizedDate":"August 22, 2024","excerpt":"\\n<h3>什么是跨域</h3>\\n<h4>定义</h4>\\n<blockquote>\\n<p>同一协议、域名、端口即为同域，即当协议、端口、域名三者均相同时，浏览器会认为是同源，允许加载该资源，否则则认为不同源，进行同源限制策略，针对不同源，如果后端没有对响应字段进行处理，则响应回的数据会被浏览器直接过滤掉。这就是大多数开发时是为什么会出现浏览器跨域报错情况的原因。</p>\\n</blockquote>\\n<h3>跨域策略限制了哪些资源和操作</h3>\\n<blockquote>\\n<p>不允许发送POST请求：在发送POST请求之前会发送OPTIONS请求，HTTP响应状态码为403（Forbidden）\\n允许发送GET请求：HTTP响应状态码为200，但是不能读取服务器返回的数据。</p>\\n</blockquote>","autoDesc":true}`);export{d as comp,m as data};
