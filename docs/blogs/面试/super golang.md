## super Golang



#### new和make的区别

new和make都是用来内存分配的，且都在堆上分配内存。make用来初始化map、slice、chan，返回引用类型本身；new的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针，new也可以初始化map,slice和chan，但是不会初始化他们的内部数据结构。



#### slice和数据的区别

数组的长度是固定的，slice的长度是可以动态调整的。数组在创建的时候需要固定长度，而slice则不需要。slice的底层也是数组实现的，slice是通过一个结构体，结构体中有cap字段（表示切片容量）、len字段（表示切片长度）和array字段（是一个指针指向底层的数组地址）。



#### slice的动态扩容说一下

当新切片需要的容量大于来被扩容容量时，直接按照新切片需要的容量扩容；当等原来切片的容量小于1024时，新切片扩容到原来切片的2倍；当原来切片的容量大于等于1024时，新切片扩容到原来的1.25倍；



#### 参数传递切片和切片指针有什么区别

切片就是一个slice结构体，结构体的中有array字段指向底层数组。所以不管传递的是切片还是切片指针，都是指向底层的同一个数组（传递切片实则是创建一个新的slice结构体，但是slice结构体的array字段还是指向原先的底层数组地址，传递切片指针就是将原先slice结构体的地址值进行传递，就不需要创建新的slice结构体而已）
所以不管是传递切片还是切片指针，在函数内对切片进行修改时都会影响到函数外的切片（除非函数内的切片是copy创建出来的或者是触发了扩容创建了新的底层数组）。

#### range遍历切片有什么需要注意的吗

range在遍历前是先将切片的值copy出一份进行遍历，所以在range中对v进行修改不会影响原切片的结果，不过可以使用切片下表的形式进行更改切片值。


#### map的底层数据结构是怎么样子的

map的底层结构体是一个hmap，hmap里面维护着buckets数组，buckets数组的数量为2^B,buckets数组中的每个元素都是bmap结构体，bmap中有tophash字段,tophash是个容量为8的uint8数组。


#### 怎么进行查找操作
首先key进行hash，通过hash后的低B位得到buckets数组的下标，查看buckets数组下标对应的元素，也就是bmap中，查看bmap中的tophash是否与key进行hash后的高8位相同，相同就再查看key值是否相同，相同就拿出value的值；如果tophash中都没有相同的值就去溢出桶中找，重复上面的步骤，知道找到key或者没有溢出桶为止。


#### 怎么进行扩容操作
map的扩容是渐进式的，即扩容操作都是拆散在每一次写操作里面。然后扩容有两个触发条件：
1、map的负载因子（长度和容量的比例）超过阈值（6.5），此时map就会认为无法承担更多的key，需要进行两倍扩容。扩容发生时会将老数据存进oldbuckets，每次对map进行增删改查的时候会触发从oldbucket中迁移到bucket的操作（渐进式），在扩容没有完全迁移完成之前，每次get或者put或者遍历数据时，都会先遍历老oldbucket再遍历bucket
2、当B < 15时，overflow的bucket数量超过了2^B 或 当B > 15时，overflow的bucket数量超过2^15。map就认为局部bmap含有过多的overflow，此时就会把后置位的数据整理到前面，这种情况下元素是发生重排而不会换桶，即相同容量扩容。


#### map是线程安全的吗，怎么现场安全使用map
不是所以map在写入的时候进行读取操作会报错，可以使用sync.mutex，sync.RWmutex，sync.map


#### mutex有几种模式


#### 那这几种方式在性能上有什么区别呢

sync.RWMutex的锁适合读多写少的场景，因为读锁可以多重加锁，当有读操作时不会阻塞读操作，会阻塞写操作。当有写操作时会阻塞写操作和读操作

sync.map对map进行读时不需要加锁，使用read和dirty两个map来进行读写分离，read和dirty都指向同一个底层的map。read相当于一个缓存层，提供了快速查找map的结构，查找过程是如果read中存在则返回，若没有则判断amended属性，判断dirty是否包含read没有的数据，若amended就去dirty中查找


#### channel的底层数据结构是什么样的



#### channel发送数据和读取数据的流程



#### 线程有几种模型，goroutine的原理了解吗

linux中的操作系统模型主要是是说内核线程和用户线程的模型，有一对一，一对 N , M 对 一，N对M

GMP模型就是G代表用户级线程就是协程，M代表内核线程，P代表调度器，P是根据系统CPU的个数去决定有多少个的，也可以通过runtime.PROCROMAX去改。



#### 在GPM模型中，G有几种状态，线程有几种状态？



#### goroutine什么时候会发生阻塞，如果G一直占用资源怎么办


#### goroutine自旋占用资源怎么解决


#### 抢占式调度树如何抢占的

实现一个负载均衡算法










说一下channel的应用场景和原理



map的实现原理能简单说一下吗？



如何实现线程安全的map?



context包有什么作用？



go反射有了解吗？说说原理和作用



线上有没有死锁的问题，怎么排查MySQL死锁的问题



有没有遇到goroutine飙升的问题，怎么排查



有没有遇到内存飙升的问题，怎么排查



有没有遇到过内存逃逸会带来什么影响



