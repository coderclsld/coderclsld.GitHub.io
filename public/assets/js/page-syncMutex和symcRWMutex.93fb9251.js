(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{501:function(t,e,s){"use strict";s.r(e);var a=s(1),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"sync-mutex和symc-rwmutex"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sync-mutex和symc-rwmutex"}},[t._v("#")]),t._v(" sync.Mutex和symc.RWMutex")]),t._v(" "),s("h3",{attrs:{id:"互斥锁sync-mutex"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁sync-mutex"}},[t._v("#")]),t._v(" 互斥锁sync.Mutex")]),t._v(" "),s("p",[s("code",[t._v("Mutex.lock()")]),t._v("获取锁\n"),s("code",[t._v("Mutex.Unlock()")]),t._v("释放锁\n在 Lock 和 Unlock 方法之间的代码段称为资源的临界区，这一区间的代码是严格被锁保护的，是线程安全的，任何一个时间点最多只能有一个goroutine在执行。")]),t._v(" "),s("h4",{attrs:{id:"sync-mutex的数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sync-mutex的数据结构"}},[t._v("#")]),t._v(" sync.Mutex的数据结构")]),t._v(" "),s("div",{staticClass:"language-go line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Mutex "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tstate "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int32")]),t._v("\n\tsema "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint32")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("sync.Mutex由两个字段构成，state用来代表当前互斥锁处于的状态，sema用于控制锁状态的信号量\n互斥锁主要记录了如下四种状态：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb72ab82c1a044f2ba460f472af7bf96~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp",alt:"img"}})]),t._v(" "),s("p",[t._v("waiter_num：记录当前等待抢这个锁的goroutine数量\nstarving：当前锁时候处于饥饿状态，0：正常状态，1：饥饿状态\nwoken：当前锁是否有goroutine已被唤醒。0：没有goroutine被唤醒，1：有goroutine正在加锁过程\nlocked：当前锁是否被goroutine持有。0：未被持有，1：已被持有\nsema信号量的作用：当持有锁的goroutine释放锁后，会释放sema信号量，这个信号量会被唤醒之前抢锁阻塞的goroutine来获取锁")]),t._v(" "),s("h4",{attrs:{id:"锁的两种模式-正常模式和饥饿模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁的两种模式-正常模式和饥饿模式"}},[t._v("#")]),t._v(" 锁的两种模式：正常模式和饥饿模式")]),t._v(" "),s("p",[t._v("正常模式下，所有阻塞在等待队列中的goroutine会按顺序进行锁获取，当唤醒一个等待队列中的goroutine时，此goroutine并不会直接获取到锁，而是会和新请求锁的goroutine竞争。    通常新请求锁的goroutine更容易获取锁，这是因为新请求锁的goroutine正在占用cpu片执行，大概率可以直接执行到获取到锁的逻辑。\n饥饿模式下， 新请求锁的goroutine不会进行锁获取，而是加入到队列尾部阻塞等待获取锁。\n饥饿模式的触发条件：当一个goroutine等待锁的时间超过了1ms，互斥锁会切换到饥饿模式\n饥饿模式的取消条件：当获取到这个锁的goroutine是等待锁队列中的最后一个goroutine，互斥锁会切换到正常模式；当获取到锁的这个goroutine的等待时间在1ms之内，互斥锁会切换到正常模式。")]),t._v(" "),s("h4",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项：")]),t._v(" "),s("p",[t._v("1、在一个goroutine中执行Lock()加锁成功后，不要再重复进行加锁，否则会panic\n2、在Lock()之前执行Unlock()释放锁会panic\n3、对于同一把锁，可以在一个goroutine中执行Lock加锁成功后，可以在另一个goroutine中执行Unlock释放锁。")]),t._v(" "),s("h3",{attrs:{id:"读写锁sync-rwmutex"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读写锁sync-rwmutex"}},[t._v("#")]),t._v(" 读写锁sync.RWMutex")]),t._v(" "),s("blockquote",[s("p",[t._v("读写锁不限制对资源的并发读，但是读写、写写操作无法并行执行")])]),t._v(" "),s("p",[s("code",[t._v("RLock()")]),t._v("申请读锁\n"),s("code",[t._v("RUnlock()")]),t._v("解除读锁\n"),s("code",[t._v("Lock()")]),t._v("申请写锁\n"),s("code",[t._v("Unlock()")]),t._v("解除写锁")]),t._v(" "),s("h4",{attrs:{id:"sync-rwmutex的数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sync-rwmutex的数据结构"}},[t._v("#")]),t._v(" sync.RWMutex的数据结构")]),t._v(" "),s("div",{staticClass:"language-go line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" RWMutex "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tw Mutex "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//复用互斥锁")]),t._v("\n\twriteSem "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//写锁监听读锁释放的信号量")]),t._v("\n\treaderSem "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//读锁监听写锁释放的信号量")]),t._v("\n\treaderCount "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//当前正在执行读操作的数量")]),t._v("\n\treaderWait "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//当写操作被阻塞时，需要等待读操作完成的个数")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h4",{attrs:{id:"读操作如何防止并发读写问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读操作如何防止并发读写问题"}},[t._v("#")]),t._v(" 读操作如何防止并发读写问题？")]),t._v(" "),s("ul",[s("li",[t._v("RLock()申请读锁，每次执行该函数都会对readerCount++，此时当有写操作执行Lock()时会判断readerCount > 0，就会被阻塞")]),t._v(" "),s("li",[t._v("RUnLock()解除读锁，执行readerCount--，释放信号量唤醒等待写操作的goroutine")])]),t._v(" "),s("h4",{attrs:{id:"写操作如何防止并发读写、并发写写问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写操作如何防止并发读写、并发写写问题"}},[t._v("#")]),t._v(" 写操作如何防止并发读写、并发写写问题？")]),t._v(" "),s("ul",[s("li",[t._v("Lock()申请写锁，获取互斥锁，此时会阻塞其他的写操作，并将readerCount置为-1，当有读操作进来时发现readerCount = -1，就知道了有写操作在进行，阻塞。")]),t._v(" "),s("li",[t._v("Unlock()解除写锁，会先通知所有阻塞的读操作goroutine，然后才会释放持有的互斥锁。")])]),t._v(" "),s("h4",{attrs:{id:"为什么写操作不会被饿死"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么写操作不会被饿死"}},[t._v("#")]),t._v(" 为什么写操作不会被饿死？")]),t._v(" "),s("ul",[s("li",[t._v("什么事写操作被饿死？这是由于写操作要等待读操作结束后才可以获取锁，而写操作在等待期间可能还有新的读操作持续到来，如果写操作等待所有的读操作结束，很可能会一直阻塞，这种现象叫做写操作被饿死")]),t._v(" "),s("li",[t._v("通过RWMutex结构体中你的readerWait属性可以完美解决这个问题，当写操作到来是，会把RWMutex.readerCount值拷贝到RWMutex.readerWait中，用于标记在写操作面前的读操作个数，前面的读操作结束后，除了会递减RWMutex.readerCount，还会递减RWMutex.readerWait值，当RWMutex.readWait值变为0时唤醒写操作。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);