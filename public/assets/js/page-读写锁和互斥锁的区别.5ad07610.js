(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{491:function(v,_,o){"use strict";o.r(_);var e=o(2),c=Object(e.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h2",{attrs:{id:"读写锁和互斥锁的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#读写锁和互斥锁的区别"}},[v._v("#")]),v._v(" 读写锁和互斥锁的区别")]),v._v(" "),o("p",[v._v("go语言标准库"),o("code",[v._v("sync")]),v._v("提供了两种锁，互斥锁"),o("code",[v._v("sync.Mutex")]),v._v("和读写锁"),o("code",[v._v("sync.RWMutex")])]),v._v(" "),o("p",[o("code",[v._v("sync.Mutex")]),v._v(",有两个方法，"),o("code",[v._v("Lock")]),v._v("和"),o("code",[v._v("Unlock")]),v._v(",我们可以通过在代码前调用 "),o("code",[v._v("Lock")]),v._v(" 方法，在代码后调用"),o("code",[v._v("Unlock")]),v._v("方法来保证一段代码的互斥执行，也可以用 "),o("code",[v._v("defer")]),v._v(" 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 "),o("code",[v._v("Lock")]),v._v(" 方法获得锁后，其他请求锁的协程都会阻塞在 "),o("code",[v._v("Lock")]),v._v("方法，直到锁被释放。")]),v._v(" "),o("p",[o("code",[v._v("sync.RWMutex")]),v._v(",读写锁分为读锁和写锁，读锁是允许同时执行的，但写锁是互斥的。"),o("code",[v._v("sync.RWMutex")]),v._v("提供四个方法，"),o("code",[v._v("Lock")]),v._v("加写锁，"),o("code",[v._v("Unlock")]),v._v("释放写锁，"),o("code",[v._v("RLock")]),v._v("加读锁，"),o("code",[v._v("RUnlock")]),v._v("释放读锁")]),v._v(" "),o("p",[v._v("读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。")]),v._v(" "),o("p",[v._v("写锁之间是互斥的，存在写锁，其他写锁阻塞。")]),v._v(" "),o("p",[v._v("写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。")]),v._v(" "),o("p",[v._v("互斥锁如何实现公平")]),v._v(" "),o("blockquote",[o("p",[v._v("互斥锁有两种状态：正常状态和饥饿状态。")]),v._v(" "),o("p",[v._v("在正常状态下，所有等待锁的"),o("code",[v._v("goroutine")]),v._v(" 按照FIFO顺序等待。唤醒的"),o("code",[v._v("goroutine")]),v._v("不会直接拥有锁，而是会和新请求锁的"),o("code",[v._v("goroutine")]),v._v("竞争锁的拥有。新请求锁的 "),o("code",[v._v("goroutine")]),v._v(" 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的"),o("code",[v._v("goroutine")]),v._v(" 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒 "),o("code",[v._v("goroutine")]),v._v("会加入到等待队列的前面。 如果一个等待的 "),o("code",[v._v("goroutine")]),v._v(" 超过 "),o("code",[v._v("1ms")]),v._v("没有获取锁，那么它将会把锁转变为饥饿模式。")]),v._v(" "),o("p",[v._v("在饥饿模式下，锁的所有权将从 unlock 的 "),o("code",[v._v("goroutine")]),v._v(" 直接交给交给等待队列中的第一个。新来的 "),o("code",[v._v("goroutine")]),v._v(" 将不会尝试去获得锁，即使锁看起来是 unlock 状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。")]),v._v(" "),o("p",[v._v("如果一个等待的 "),o("code",[v._v("goroutine")]),v._v(" 获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于"),o("code",[v._v("1ms")]),v._v("。它会将锁的状态转换为正常状态。")]),v._v(" "),o("p",[v._v("正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。")])])])}),[],!1,null,null,null);_.default=c.exports}}]);