(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{512:function(_,v,l){"use strict";l.r(v);var e=l(2),a=Object(e.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h2",{attrs:{id:"todo"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#todo"}},[_._v("#")]),_._v(" Todo")]),_._v(" "),l("ul",[l("li",[_._v("[ ] goland设计模式")]),_._v(" "),l("li",[_._v("[ ] goland一些开源框架的架构、怎么在一个框架中加入更多的东西")]),_._v(" "),l("li",[_._v("[ ] 元数据是什么。怎么用到数据定义上了来，为什么埋点都有metric上报数据格式，可否自定")]),_._v(" "),l("li",[_._v("[ ] 一个测试进行软件测试的时候需要的步骤")]),_._v(" "),l("li",[_._v("[ ] 服务端打包，下发包逻辑原理，可否携带参数")]),_._v(" "),l("li",[_._v("[ ] 大数据解决了原先MySQL什么问题")]),_._v(" "),l("li",[_._v("[ ] 字节对齐内存占用浪费goland cl linter benchmark")]),_._v(" "),l("li",[_._v("[ ] Slice 统计每个字母出现的个数")]),_._v(" "),l("li",[_._v("[ ] 单元测试模拟")]),_._v(" "),l("li",[_._v("[ ] 并发的去计算出现的个数可以这么进行优化，给一个参数可以去控制启动的worker")]),_._v(" "),l("li",[_._v("[ ] 怎么通过加锁去控制统计的个数")]),_._v(" "),l("li",[_._v("[ ] 怎么通过channel去完成，生产者加消费者模型")]),_._v(" "),l("li",[_._v("[ ] struct在进行初始化的时候可以进行什么优化，相邻内存分配")]),_._v(" "),l("li",[_._v("[ ] channel在初始化的时候为什么会给多一个buffer缓冲")]),_._v(" "),l("li",[_._v("[ ] select{}语句是随机进行匹配还是按照代码顺序进行匹配的")]),_._v(" "),l("li",[_._v("[x] 前端与客户端进行桥接")]),_._v(" "),l("li",[_._v("[x] 半小时看看有没有思路，实现一个分布式的mapreduce")]),_._v(" "),l("li",[_._v("[x] go怎么实现接口和数据节点都解耦的，怎么进行自由扩展，go如何实现类似于java当中的继承机制？")]),_._v(" "),l("li",[_._v("[x] go实现面向对象的机制？怎么去复用一个接口的方法？")]),_._v(" "),l("li",[_._v("[x] ES怎么结合结构体信息（元数据）、NEO4j")]),_._v(" "),l("li",[_._v("[x] 怎么做断点续传，指定range头部，断点续传有一个数据节点垮掉了怎么办。，需要怎么去改进")]),_._v(" "),l("li",[_._v("[x] fork一个子进程，父进程垮掉了会影响子进程吗，父进程获取不到子进程的ID会怎么要，子进程获取不到父进程的id会怎么样，父进程会的呢带子进程运行完毕吗")]),_._v(" "),l("li",[_._v("[x] 孤儿进程和僵尸进程，守护进程")]),_._v(" "),l("li",[_._v("[x] linux文件权限 rwx")]),_._v(" "),l("li",[_._v("[x] go map查询一个key到获取到value的全过程")]),_._v(" "),l("li",[_._v("[x] go select 当多个分支 同时满足条件时. select 是怎么处理的 ?")]),_._v(" "),l("li",[_._v("[x] 游戏昵称（将游戏昵称可以在帖子编辑界面中显示）")]),_._v(" "),l("li",[_._v("[x] 发帖任务排序（首页推荐的2款游戏>最近在玩游戏>流水top20游戏）")]),_._v(" "),l("li",[_._v("[x] 后台添加视频攻略内容")])]),_._v(" "),l("h3",{attrs:{id:"_2022-12-15"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2022-12-15"}},[_._v("#")]),_._v(" 2022-12-15")]),_._v(" "),l("ul",[l("li",[_._v("[ ] k8s\n"),l("ul",[l("li",[_._v("[ ] do learing plan")])])]),_._v(" "),l("li",[_._v("[ ] grpc project\n"),l("ul",[l("li",[_._v("[ ] 协议定义、生成")]),_._v(" "),l("li",[_._v("[ ] 各种中间件")])])]),_._v(" "),l("li",[_._v("[ ] now boss goland\n"),l("ul",[l("li",[_._v("[ ] target")]),_._v(" "),l("li",[_._v("[ ] strack")])])]),_._v(" "),l("li",[_._v("[ ] 疑难杂症经验\n"),l("ul",[l("li",[_._v("[ ] go调优")]),_._v(" "),l("li",[_._v("[ ] 优秀工具")])])]),_._v(" "),l("li",[_._v("[ ] 接下来的升级路线")])]),_._v(" "),l("h3",{attrs:{id:"_2022-12-19"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2022-12-19"}},[_._v("#")]),_._v(" 2022-12-19")]),_._v(" "),l("ul",[l("li",[_._v("[ ] 悬赏管理开发")]),_._v(" "),l("li",[_._v("[ ] 分片上传开发")])]),_._v(" "),l("h3",{attrs:{id:"_2022-12-23"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2022-12-23"}},[_._v("#")]),_._v(" 2022-12-23")]),_._v(" "),l("ul",[l("li",[_._v("[x] 分片上传为什么会这么慢，解决")]),_._v(" "),l("li",[_._v("[x] 凤凰架构")])]),_._v(" "),l("h3",{attrs:{id:"_2022-12-24"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2022-12-24"}},[_._v("#")]),_._v(" 2022-12-24")]),_._v(" "),l("ul",[l("li",[_._v("[x] 绩效考核")]),_._v(" "),l("li",[_._v("[ ] k8s集群搭建")])]),_._v(" "),l("h3",{attrs:{id:"_2022-12-26"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2022-12-26"}},[_._v("#")]),_._v(" 2022-12-26")]),_._v(" "),l("ul",[l("li",[_._v("[x] 回顾一下有哪些需要部署正服的\n"),l("ul",[l("li",[_._v("[x] appbanner后台")]),_._v(" "),l("li",[_._v("[x] ll_game_strategy_base")]),_._v(" "),l("li",[_._v("[x] 官方帖子")])])]),_._v(" "),l("li",[_._v("[x] 看一下项目框架")])]),_._v(" "),l("h3",{attrs:{id:"_2022-12-28"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2022-12-28"}},[_._v("#")]),_._v(" 2022-12-28")]),_._v(" "),l("ul",[l("li",[_._v("[x] ll_game_strategy_base")]),_._v(" "),l("li",[_._v("[x] 后台管理路由")])]),_._v(" "),l("h3",{attrs:{id:"_2023-1-7"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2023-1-7"}},[_._v("#")]),_._v(" 2023-1-7")]),_._v(" "),l("h3",{attrs:{id:"_2023-1-16"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2023-1-16"}},[_._v("#")]),_._v(" 2023-1-16")]),_._v(" "),l("ul",[l("li",[_._v("[x] zero copy怎么实现的？")]),_._v(" "),l("li",[_._v("[ ] 有一个很大的文件，如何快速找到前n个出现次数最多的单词")]),_._v(" "),l("li",[_._v("[x] 慢查询怎么发现，怎么排查，怎么优化")]),_._v(" "),l("li",[_._v("[x] kafka批量消费，如果消费过长，会导致消费超时，触发rebalance吧？")]),_._v(" "),l("li",[_._v("[ ] LRU cache怎么实现？get()/put()复杂度如何？如何实现过期？如何避免过期遍历所有？")]),_._v(" "),l("li",[_._v("[x] 有一批帖子，会根据类别搜索，但是现在是单独一个表，现在查询非常慢，如何提高搜索性能？")]),_._v(" "),l("li",[_._v("[x] 分表的数据，动态增加一张表，不停服如何实现？")]),_._v(" "),l("li",[_._v("[x] 如何保证数据库和ES数据的一致性\n"),l("a",{attrs:{href:"https://www.modb.pro/db/420079",target:"_blank",rel:"noopener noreferrer"}},[_._v("ES、DB同步案例"),l("OutboundLink")],1)]),_._v(" "),l("li",[_._v("[x] NEWSQL，例如tidb、leveldb、hbase使用LSM树，有了解过为什么吗？")]),_._v(" "),l("li",[_._v("[x] context包的用途")]),_._v(" "),l("li",[_._v("[x] inux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程")])]),_._v(" "),l("h3",{attrs:{id:"_2023-02-04"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2023-02-04"}},[_._v("#")]),_._v(" 2023-02-04")]),_._v(" "),l("ul",[l("li",[_._v("[x] map相关面试题\n"),l("ul",[l("li",[_._v("[x] map底层数据结构\n"),l("ul",[l("li",[_._v("[x] map的查找")]),_._v(" "),l("li",[_._v("[x] map的扩容")])])]),_._v(" "),l("li",[_._v("[x] map的用法")])])]),_._v(" "),l("li",[_._v("[x] slice相关面试题\n"),l("ul",[l("li",[_._v("[x] slice底层结构\n"),l("ul",[l("li",[_._v("[x] 如何扩容")]),_._v(" "),l("li",[_._v("[x] 如何查找")])])]),_._v(" "),l("li",[_._v("[x] slice的用法")])])]),_._v(" "),l("li",[_._v("[x] channel相关面试题\n"),l("ul",[l("li",[_._v("[ ] channel的底层数据结构")]),_._v(" "),l("li",[_._v("[ ] 有缓冲channel和无缓冲channel")]),_._v(" "),l("li",[_._v("[ ] 防止channel阻塞、死锁")]),_._v(" "),l("li",[_._v("[ ] 对已经关闭的channel进行读写")])])]),_._v(" "),l("li",[_._v("[ ] go内存模型相关面试题\n"),l("ul",[l("li",[_._v("[ ] 如何判断一个对象是分配在栈上还是堆上")]),_._v(" "),l("li",[_._v("[ ] 内存逃逸分析\n"),l("ul",[l("li",[_._v("[ ] 函数返回局部变量的指针是否安全")])])]),_._v(" "),l("li",[_._v("[ ] 内存管理、内存池")])])]),_._v(" "),l("li",[_._v("[ ] go垃圾回收相关面试题\n"),l("ul",[l("li",[_._v("[ ] 垃圾回收机制")])])]),_._v(" "),l("li",[_._v("[ ] goroutine相关面试题\n"),l("ul",[l("li",[_._v("[ ] GMP模型")]),_._v(" "),l("li",[_._v("[ ] 什么是协程")]),_._v(" "),l("li",[_._v("[ ] goroutine操作函数")]),_._v(" "),l("li",[_._v("[ ] goroutine什么情况会发生内存泄露，如何避免")])])]),_._v(" "),l("li",[_._v("[ ] 锁\n"),l("ul",[l("li",[_._v("[ ] mutex")]),_._v(" "),l("li",[_._v("[ ] atomic")])])]),_._v(" "),l("li",[_._v("[ ] leetcode小试牛刀")])]),_._v(" "),l("h3",{attrs:{id:"_2023-02-26"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2023-02-26"}},[_._v("#")]),_._v(" 2023-02-26")]),_._v(" "),l("ul",[l("li",[_._v("[ ] GMP")])]),_._v(" "),l("blockquote",[l("p",[l("a",{attrs:{href:"https://learnku.com/articles/41728",target:"_blank",rel:"noopener noreferrer"}},[_._v("Golang三关-典藏版 Golang 调度器 GMP 原理与调度全分析 | Go 技术论坛 (learnku.com)"),l("OutboundLink")],1)]),_._v(" "),l("p",[_._v("其实线程分为内核态线程和用户态线程，每一个内核态线程可以与一个用户态")]),_._v(" "),l("ul",[l("li",[_._v("G：goroutine，用户态线程，有自己对的栈，instruction pointer和其他信息（正在等待的channel等），用于调度")]),_._v(" "),l("li",[_._v("P：processor，代表执行所需要的资源（调度的上下文，队列等），实现从N:1到N:M的关键")]),_._v(" "),l("li",[_._v("M：系统内核线程")]),_._v(" "),l("li",[_._v("global runqueue：未分配Processer的goroutine保存在全局队列中，Processer或M都可以con全局队列中取出G")]),_._v(" "),l("li",[_._v("local runqueue：是Processer的队列，当队列为空时，会从全局队列或其他队列中补充Goroutine")])]),_._v(" "),l("p",[_._v("P的数量可以通过GOMAXPROCS()来设置，他其实就代表着真正的并发度，有多少个goroutine可以同时运行")]),_._v(" "),l("p",[_._v("P每个时刻只能运行一个goroutine，没有被运行的goroutine就会被放到runqueue中，等待被调度")]),_._v(" "),l("p",[_._v("为何要维护线程上下文P，因为当一个OS线程被柱塞时，P就可以投奔到另一个OS线程")]),_._v(" "),l("p",[_._v("为了保证公平性和防止 Goroutine 饥饿问题，Go 程序会保证每个 G 运行 10ms 就让出 M，交给其他 G 去执行，这个 G 运行 10ms 就让出 M 的机制，是由单独的系统监控线程通过 retake() 函数给当前的 G 发送抢占信号（基于信号的抢占式调度机制）实现的，如果所在的 P 没有陷入系统调用且没有满，让出的 G 优先进入本地 P 队列，否则进入全局队列")]),_._v(" "),l("p",[_._v("G 在运行时中的状态可以简化成三种：等待中_Gwaiting、可运行_Grunnable、运行中_Grunning，运行期间大部分情况是在这三种状态间来回切换")]),_._v(" "),l("p",[_._v("M 的状态可以简化为只有两种：自旋和非自旋；"),l("strong",[_._v("自旋状态，表示 M 绑定了 P 又没有获取 G")]),_._v("；非自旋状态，表示正在执行 Go 代码中，或正在进入系统调用，或空闲")]),_._v(" "),l("p",[l("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/586236582",target:"_blank",rel:"noopener noreferrer"}},[_._v("深入分析Go1.18 GMP调度器底层原理 - 知乎 (zhihu.com)"),l("OutboundLink")],1)])]),_._v(" "),l("ul",[l("li",[_._v("[ ] slice、map、chan")])]),_._v(" "),l("p",[_._v("slice的查找、扩容机制")]),_._v(" "),l("blockquote"),_._v(" "),l("p",[_._v("深拷贝和浅拷贝")]),_._v(" "),l("blockquote",[l("p",[_._v("浅拷贝：复制出来的对象和原对象指向同一个地址，通过=，[:]进行复制和切片")]),_._v(" "),l("p",[_._v("深拷贝：复制出来的对象和原对象不指向同一个地址，通过copy()，复制出一份切片")])]),_._v(" "),l("p",[_._v("参数传递切片和切片指针的区别")]),_._v(" "),l("blockquote"),_._v(" "),l("p",[_._v("map查找、扩容机制")]),_._v(" "),l("blockquote"),_._v(" "),l("p",[_._v("线程安全map怎么实现，sync.map和原生map")]),_._v(" "),l("blockquote"),_._v(" "),l("p",[_._v("为什么遍历map是无序的，怎么实现有序遍历")]),_._v(" "),l("blockquote"),_._v(" "),l("p",[_._v("context的结构，使用场景和用途？")]),_._v(" "),l("blockquote"),_._v(" "),l("p",[_._v("channel的底层原理")]),_._v(" "),l("blockquote"),_._v(" "),l("ul",[l("li",[_._v("[ ] go runtime")])]),_._v(" "),l("blockquote",[l("p",[l("a",{attrs:{href:"https://mp.weixin.qq.com/s/ivO-USpxiyrL-9BzgE8Vcg",target:"_blank",rel:"noopener noreferrer"}},[_._v("深度长文：深入Go Runtime，你能做到浅出吗? (qq.com)"),l("OutboundLink")],1)]),_._v(" "),l("p",[_._v("内存分配，类似于TCMalloc")]),_._v(" "),l("ul",[l("li",[_._v("使用span机制来减少碎片，每个span至少为一个页（go中一个page为8KB），每一种span用于一个范围的内存分配需求，比如16-32byte使用分配32byte的span，112-128使用分配128byte的span。一共有67个size范围，8byte-32KB，每个size有两种类型（scan和noscan，表示分配的对象是否包含指针）")]),_._v(" "),l("li",[_._v("多层次的Cache来减少分配的冲突，per-P无锁的mcache，全局67*2个对应不同size的span的后背mcentral，全局一个的mheap，mheap中以treap的结构维护空闲连续page，归还内存到mheap时，连续地址会进行合并。")]),_._v(" "),l("li",[_._v("go代码分配内存优先从当前P的mcache对应size的span中获取，有的话再从对应size的mcentral中获取一个span，还没有的话从mheap中sweep一个span；sweep不出来，则从mheap中空闲块找到对应span大小的内存，mheap中如果还没有，则从系统申请内存，从无锁到全局1/(67*2)粒度的锁，再到全局锁，再到系统调用。")]),_._v(" "),l("li",[_._v("stack分配也是多层次和多class的，减少分配的锁争抢，减少栈浪费。")]),_._v(" "),l("li",[_._v("对象由GC进行回收，sysmon会定时吧空余的内存归还给操作系统。")])]),_._v(" "),l("p",[_._v("mspan、mcache、mcentral、mheap")]),_._v(" "),l("p",[_._v("mcache：在GMP模型下，会在每个P下都有一个mcache字段，用来表示内存信息，在go 1.2版本前调度器使用的是GM模型，将mcache放在了M里，但发现存在诸多问题，其中对内存这一块存在巨大的浪费，每个M都持有mcache和stack alloc，但只有在M运行go代码的时候才需要使用的内存，当M在处于syscall或网络请求的时候是不需要的，在加上M又是运行创建许多个的，这就造成极大的浪费。所以在go 1.3版本开始使用了GMP模型，这样在高并发状态下，每个G只有在运行的时候才会使用到内存，而每个G会绑定一个P，所以他们在运行时只占用一份mcache，对于mcache的数量就是P的数量，同时并发访问时也不会产生锁。")]),_._v(" "),l("p",[_._v("mspan：mcache中持有一系列的mspan从8字节到32KB分了大概67种mspan")]),_._v(" "),l("p",[_._v("mcentral：如果分配内存时mcache没有空闲的32KB的mspan就去mcentral里拿取，mcentral里面会维护着所有span范围大小的mspan列表，包括已分配出去的和未分配出去的，所以mcentral存在多个goroutine竞争的情况，因此从mcentral获取支援的时候需要加锁。"),l("strong",[_._v("nonempty")]),_._v("表示链表里还有空闲的"),l("code",[_._v("mspan")]),_._v("待分配。"),l("strong",[_._v("empty")]),_._v("表示这条链表里的"),l("code",[_._v("mspan")]),_._v("都被分配了"),l("code",[_._v("object")])]),_._v(" "),l("p",[_._v("mheap：mheap主要用于大对象的内存分配（或者直接大于32KB的内存申请），以及管理未切割的mspan，用于给mcentral切割成小对象，所有的mcentral集合都是放在mheap里面的，nheap里面的arena区域才是真正的兑取，运行时会将8KB看做一页，这些内存页存储了所有在堆上进行初始化的对象。运行时使用"),l("code",[_._v("runtime.heapArena")]),_._v("数组管理所有内存，如果arena区域没有足够的空间，会调用"),l("code",[_._v("runtime.mheap.sysAlloc")]),_._v("从操作系统中申请更多的内存")]),_._v(" "),l("p",[_._v("GC")]),_._v(" "),l("p",[_._v("三色标记：")]),_._v(" "),l("ul",[l("li",[_._v("有黑白灰三个集合，初始化时所有对象都是白色的")]),_._v(" "),l("li",[_._v("从Root对象开始标记，将所有可达对象标记为灰色")]),_._v(" "),l("li",[_._v("从灰色对象集合取出对象，将其引用的对象标记为灰色，放入灰色集合，并将自己标记为黑色。")]),_._v(" "),l("li",[_._v("重复第三步，直到灰色集合为空，即所有可达对象都被标记。")]),_._v(" "),l("li",[_._v("标记结束后，不可达的白色对象即为垃圾，对内存进行迭代清扫，回收白色对象。")])]),_._v(" "),l("p",[_._v("三色标记需要维护不变性条件：黑色对象不能引用无法被灰色对象可达的白色对象。并发标记时如果没有在正确的保障措施，可能会导致漏标记对象，导致实际上可达的对象被清扫掉。为你解决这个问题，go使用了写屏障（和内存写屏障不是同一个概念），写屏障是在写入指针前执行的一小段代码，用以防止并发标记时指针丢失，这一小段代码go是在编译时加入的")])]),_._v(" "),l("h3",{attrs:{id:"_2023-2-27"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2023-2-27"}},[_._v("#")]),_._v(" 2023-2-27")]),_._v(" "),l("ul",[l("li",[_._v("[x] 话题增加视频上传功能(已添加，前端还未支持)")]),_._v(" "),l("li",[_._v("[ ] 安装lc插件")])])])}),[],!1,null,null,null);v.default=a.exports}}]);